// Generated by CoffeeScript 1.7.1
(function() {
  var Promise, browserify, buildPages, buildScripts, buildStyles, compileTemplate, compileTemplates, copyFontAwesome, copyImages, exec, fs, glob, less, log, mkdirp, moment, path, rimraf, rsvp, signalDone, signalError, startBuild, uglifyify, _;

  fs = require('fs');

  mkdirp = require('mkdirp');

  rimraf = require('rimraf');

  rsvp = require('rsvp');

  _ = require('lodash');

  browserify = require('browserify');

  glob = require('glob');

  path = require('path');

  Promise = rsvp.Promise;

  less = require('less');

  uglifyify = require('uglifyify');

  exec = require('child_process').exec;

  moment = require('moment');

  log = require('./log');

  buildPages = require('./build_pages');

  startBuild = function(ctx) {
    ctx.startedAt = moment();
    return new Promise(function(resolve, reject) {
      mkdirp.sync(ctx.args.buildDir);
      mkdirp.sync(ctx.args.tmpDir);
      _.each(['css', 'js', 'fonts', 'images'], function(dir) {
        return mkdirp.sync("" + ctx.args.buildDir + "/" + dir);
      });
      return resolve(ctx);
    });
  };

  compileTemplate = function(template, ctx) {
    var CoffeeScript, compiler;
    log.debug("Recompiling template " + template);
    CoffeeScript = require('coffee-script');
    compiler = new (require('../node_modules/haml-coffee/src/haml-coffee'))({
      placement: 'standalone',
      uglify: ctx.args.compress
    });
    compiler.parse(fs.readFileSync(template, {
      encoding: 'utf8'
    }));
    return CoffeeScript.compile(compiler.precompile(), {
      bare: true
    });
  };

  compileTemplates = function(ctx) {
    var startedAt;
    startedAt = moment();
    log.debug("Started compiling templates");
    return new Promise(function(resolve, reject) {
      var cache, cacheFile, jstSrc, sources;
      sources = glob.sync("" + ctx.args.srcDir + "/**/*.hamlc");
      cacheFile = "" + ctx.args.tmpDir + "/templates.json";
      cache = (function() {
        try {
          return JSON.parse(fs.readFileSync(cacheFile, {
            encoding: 'utf8'
          }));
        } catch (_error) {
          log.warn("Could not load template cache; starting from scratch");
          return {};
        }
      })();
      _.each(sources, function(template) {
        var _ref;
        if (fs.statSync(template).mtime > (((_ref = cache[template]) != null ? _ref.mtime : void 0) || 0)) {
          return cache[template] = {
            mtime: +new Date(),
            js: compileTemplate(template, ctx)
          };
        }
      });
      fs.writeFileSync(cacheFile, JSON.stringify(cache));
      jstSrc = _.reduce(cache, function(out, _arg, file) {
        var js, key;
        js = _arg.js;
        key = path.relative(ctx.args.srcDir, file);
        key = path.basename(key, path.extname(key));
        return out + ("module.exports[\"" + key + "\"] = function(ctx) {\n return (function() {\n " + js + "\n }).call(ctx); };\n");
      }, 'var _ = require("lodash");\nmodule.exports = {};\n');
      fs.writeFileSync("" + ctx.args.tmpDir + "/templates.jst", jstSrc);
      log.debug("Finished compiling templates in " + (moment().diff(startedAt)) + "ms");
      ctx.JST = eval("(function(){ " + jstSrc + "; return module.exports;}).call()");
      return resolve(ctx);
    });
  };

  buildScripts = function(ctx) {
    var startedAt;
    startedAt = moment();
    return new Promise(function(resolve, reject) {
      var bundle;
      bundle = browserify({
        entries: ["" + ctx.args.srcDir + "/" + ctx.args.mainScript],
        extensions: ['.jst', '.coffee'],
        ignoreMissing: true
      });
      bundle.transform(require('coffeeify'));
      if (ctx.args.compress) {
        bundle.transform(require('uglifyify'));
      }
      bundle.transform(require('debowerify'));
      return bundle.bundle(function(err, src) {
        if (err) {
          return reject(err);
        } else {
          fs.writeFileSync("" + ctx.args.buildDir + "/js/all.js", src);
          log.debug("Finished compiling scripts in " + (moment().diff(startedAt)) + "ms");
          return resolve(ctx);
        }
      });
    });
  };

  buildStyles = function(ctx) {
    var startedAt;
    startedAt = moment();
    return new Promise(function(resolve, reject) {
      var files, parser, src;
      files = glob.sync("" + ctx.args.srcDir + "/**/*.+(less|css)");
      src = _.reduce(files, function(src, path) {
        return src + fs.readFileSync(path);
      }, '');
      parser = new less.Parser({
        paths: [ctx.args.srcDir, ctx.args.bowerDir],
        filename: 'bundle.less'
      });
      return parser.parse(src, function(err, tree) {
        var css;
        if (err) {
          return reject(err);
        } else {
          css = tree.toCSS({
            compress: ctx.args.compress
          });
          fs.writeFileSync("" + ctx.args.buildDir + "/css/all.css", css);
          log.debug("Finished compiling styles in " + (moment().diff(startedAt)) + "ms");
          return resolve(ctx);
        }
      });
    });
  };

  copyFontAwesome = function(ctx) {
    return new Promise(function(resolve, reject) {
      var dst, faDir, src;
      faDir = "" + ctx.args.bowerDir + "/font-awesome";
      if (fs.existsSync(faDir)) {
        src = "" + faDir + "/fonts/*";
        dst = "" + ctx.args.buildDir + "/fonts/";
        return exec("cp " + src + " " + dst, function(err, out) {
          if (err) {
            return reject(err);
          } else {
            return resolve(ctx);
          }
        });
      } else {
        return resolve(ctx);
      }
    });
  };

  copyImages = function(ctx) {
    var startedAt;
    startedAt = moment();
    return new Promise(function(resolve, reject) {
      var images, promises;
      log.debug("Started copying images");
      images = glob.sync("" + ctx.args.srcDir + "/**/*.+(jpg|png)");
      promises = _.map(images, function(file) {
        return new Promise(function(resolve, reject) {
          var dst, relPath;
          relPath = path.relative(ctx.args.srcDir, file);
          dst = "" + ctx.args.buildDir + "/images/" + (path.dirname(relPath));
          return exec("mkdir -p " + dst + " && cp " + file + " " + dst, function(err) {
            if (err) {
              return reject(err);
            } else {
              return resolve();
            }
          });
        });
      });
      if (promises.length > 0) {
        return rsvp.all(promises).then(function() {
          log.debug("Finished copying images in " + (moment().diff(startedAt)) + "ms");
          return resolve(ctx);
        });
      } else {
        log.debug("No images found");
        return resolve(ctx);
      }
    });
  };

  signalDone = function(ctx) {
    return new Promise(function(resolve, reject) {
      log("Build finished in " + (moment().diff(ctx.startedAt)) + "ms");
      return resolve(ctx);
    });
  };

  signalError = function(err) {
    return log("Error building", err, err.stack);
  };

  module.exports = {
    run: function(args) {
      return startBuild({
        args: args
      }).then(function(ctx) {
        return compileTemplates(ctx);
      }).then(function(ctx) {
        return new Promise(function(resolve, reject) {
          var steps;
          steps = rsvp.all(_.map([buildScripts, buildStyles, copyFontAwesome, copyImages], function(fn) {
            return fn(ctx);
          }));
          steps.then(function() {
            return resolve(ctx);
          });
          return steps.then(null, reject);
        });
      }).then(function(ctx) {
        return buildPages(ctx);
      }).then(function(ctx) {
        return signalDone(ctx);
      }).then(null, function(err) {
        return signalError(err);
      });
    }
  };

}).call(this);
