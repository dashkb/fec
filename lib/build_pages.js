// Generated by CoffeeScript 1.7.0
(function() {
  var Promise, addGitMetadata, buildPages, dateFormat, exec, extractFrontMatter, fm, fs, glob, hamlc, highlight, log, marked, moment, path, renderPages, rsvp, slugify, _;

  _ = require('lodash');

  fs = require('fs');

  path = require('path');

  exec = require('child_process').exec;

  fm = require('front-matter');

  glob = require('glob');

  rsvp = require('rsvp');

  hamlc = require('haml-coffee');

  marked = require('marked');

  highlight = require('highlight.js');

  moment = require('moment');

  slugify = require('slug');

  Promise = rsvp.Promise;

  log = require('./log');

  dateFormat = 'MMMM Do YYYY, h:mm:ss a';

  extractFrontMatter = function(ctx) {
    var startedAt;
    startedAt = moment();
    return new Promise(function(resolve, reject) {
      var files;
      log.debug("Started extracting front matter");
      files = glob.sync("" + ctx.args.srcDir + "/**/*.md");
      ctx.pageMetadata = _.reduce(files, function(data, file) {
        var attributes, body, dest, relativePath, slug, _ref;
        relativePath = path.relative(ctx.args.srcDir, file);
        _ref = fm(fs.readFileSync(file, {
          encoding: 'utf8'
        })), attributes = _ref.attributes, body = _ref.body;
        fs.writeFileSync("" + ctx.args.buildDir + "/" + relativePath, body);
        slug = slugify(attributes.slug || attributes.title || path.basename(file, '.md')).toLowerCase();
        dest = "" + (path.dirname(relativePath)) + "/" + slug + ".html";
        data[relativePath] = _.extend({
          slug: slug,
          path: dest,
          template: 'article',
          index: true
        }, attributes);
        return data;
      }, {});
      log.debug("Finished extracting front matter in " + (moment().diff(startedAt)) + "ms");
      return resolve(ctx);
    });
  };

  addGitMetadata = function(ctx) {
    var startedAt;
    startedAt = moment();
    return new Promise(function(resolve, reject) {
      var files, promises;
      log.debug("Started extracting git metadata");
      files = glob.sync("" + ctx.args.srcDir + "/**/*.md");
      promises = _.map(files, function(file) {
        var relativePath;
        relativePath = path.relative(ctx.args.srcDir, file);
        return new Promise(function(resolve, reject) {
          return exec("git log --follow --pretty=\"format:%h|%ai\" " + file, function(err, output) {
            var md;
            md = ctx.pageMetadata[relativePath];
            md.revisions = _.map(output.split("\n"), function(line) {
              var date, sha, _ref;
              _ref = line.split('|'), sha = _ref[0], date = _ref[1];
              return {
                sha: sha,
                date: date
              };
            });
            return resolve();
          });
        });
      });
      return rsvp.all(promises).then(function() {
        log.debug("Finished extracting git metadata in " + (moment().diff(startedAt)) + "ms");
        return resolve(ctx);
      });
    });
  };

  renderPages = function(ctx) {
    var startedAt;
    startedAt = moment();
    return new Promise(function(resolve, reject) {
      var files;
      log.debug("Started rendering pages");
      files = glob.sync("" + ctx.args.buildDir + "/**/*.md");
      _.each(files, function(file) {
        var dest, html, md, pageData, relativePath;
        relativePath = path.relative(ctx.args.buildDir, file);
        if (ctx.args.renderDrafts || !ctx.pageMetadata[relativePath].draft) {
          md = fs.readFileSync(file);
          html = marked(String(md), {
            gfm: true,
            tables: true,
            smartypants: true,
            smartLists: true,
            highlight: function(code, lang) {
              return highlight.highlight(lang, code).value;
            },
            langPrefix: ''
          });
          pageData = {
            site: {
              pages: ctx.pageMetadata
            },
            page: _.extend(ctx.pageMetadata[relativePath], {
              html: html
            }),
            JST: ctx.JST,
            helpers: {
              date: function(date) {
                return moment(date).format(dateFormat);
              },
              _: _,
              articles: _(ctx.pageMetadata).values().filter(function(page) {
                return page.template === 'article' && page.index;
              }).sortBy(function(page) {
                return _.first(page.revisions).date;
              }).reverse().value()
            }
          };
          dest = "" + ctx.args.buildDir + "/" + pageData.page.path;
          fs.writeFileSync(dest, pageData.JST[ctx.args.mainTemplate](pageData));
        }
        return fs.unlinkSync(file);
      });
      log.debug("Finished rendering pages in " + (moment().diff(startedAt)) + "ms");
      return resolve(ctx);
    });
  };

  module.exports = buildPages = function(ctx) {
    var startedAt;
    startedAt = moment();
    log.debug("Started building pages");
    return new Promise(function(resolve, reject) {
      return extractFrontMatter(ctx).then(function(ctx) {
        return addGitMetadata(ctx);
      }).then(function(ctx) {
        return renderPages(ctx);
      }).then(function(ctx) {
        log.debug("Finished building pages in " + (moment().diff(startedAt)) + "ms");
        return resolve(ctx);
      }).then(null, function(err) {
        return reject(err);
      });
    });
  };

}).call(this);
